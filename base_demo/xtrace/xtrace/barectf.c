/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-2020 Philippe Proulx <pproulx@efficios.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * The following code was generated by barectf v3.0.1
 * on 2022-06-22T21:27:42.063940.
 *
 * For more details, see <https://barectf.org/>.
 */

#include <stdint.h>
#include <string.h>
#include <assert.h>

#include "barectf.h"
#include "barectf-bitfield.h"

#define _ALIGN(_at_var, _align)						\
	do {								\
		(_at_var) = ((_at_var) + ((_align) - 1)) & -(_align);	\
	} while (0)

#ifdef __cplusplus
# define _TO_VOID_PTR(_value)		static_cast<void *>(_value)
# define _FROM_VOID_PTR(_type, _value)	static_cast<_type *>(_value)
#else
# define _TO_VOID_PTR(_value)		((void *) (_value))
# define _FROM_VOID_PTR(_type, _value)	((_type *) (_value))
#endif

#define _BITS_TO_BYTES(_x)	((_x) >> 3)
#define _BYTES_TO_BITS(_x)	((_x) << 3)

union _f2u {
	float f;
	uint32_t u;
};

union _d2u {
	double f;
	uint64_t u;
};

uint32_t barectf_packet_size(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->packet_size;
}

int barectf_packet_is_full(const void * const vctx)
{
	const struct barectf_ctx * const ctx = _FROM_VOID_PTR(const struct barectf_ctx, vctx);

	return ctx->at == ctx->packet_size;
}

int barectf_packet_is_empty(const void * const vctx)
{
	const struct barectf_ctx * const ctx = _FROM_VOID_PTR(const struct barectf_ctx, vctx);

	return ctx->at <= ctx->off_content;
}

uint32_t barectf_packet_events_discarded(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->events_discarded;
}

uint32_t barectf_discarded_event_records_count(const void * const vctx)
{
	return barectf_packet_events_discarded(vctx);
}

uint8_t *barectf_packet_buf(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->buf;
}

uint8_t *barectf_packet_buf_addr(const void * const vctx)
{
	return barectf_packet_buf(vctx);
}

uint32_t barectf_packet_buf_size(const void * const vctx)
{
	const struct barectf_ctx * const ctx = _FROM_VOID_PTR(const struct barectf_ctx, vctx);

	return _BITS_TO_BYTES(ctx->packet_size);
}

void barectf_packet_set_buf(void * const vctx, uint8_t * const buf,
		const uint32_t buf_size)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	ctx->buf = buf;

	if (ctx->at == ctx->packet_size) {
		/* Keep full packet state */
		ctx->at = _BYTES_TO_BITS(buf_size);
	}

	ctx->packet_size = _BYTES_TO_BITS(buf_size);
}

int barectf_packet_is_open(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->packet_is_open;
}

int barectf_is_in_tracing_section(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->in_tracing_section;
}

volatile const int *barectf_is_in_tracing_section_ptr(const void * const vctx)
{
	return &_FROM_VOID_PTR(const struct barectf_ctx, vctx)->in_tracing_section;
}

int barectf_is_tracing_enabled(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->is_tracing_enabled;
}

void barectf_enable_tracing(void * const vctx, const int enable)
{
	_FROM_VOID_PTR(struct barectf_ctx, vctx)->is_tracing_enabled = enable;
}

static
void _write_c_str(struct barectf_ctx * const ctx, const char * const src)
{
	const uint32_t sz = strlen(src) + 1;

	memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], src, sz);
	ctx->at += _BYTES_TO_BITS(sz);
}

static
int _reserve_er_space(void * const vctx, const uint32_t er_size)
{
	int ret;
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Event _cannot_ fit? */
	if (er_size > (ctx->packet_size - ctx->off_content)) {
		goto no_space;
	}

	/* Packet is full? */
	if (barectf_packet_is_full(ctx)) {
		/* Yes: is the back end full? */
		if (ctx->cbs.is_backend_full(ctx->data)) {
			/* Yes: discard event record */
			goto no_space;
		}

		/* Back-end is _not_ full: open new packet */
		ctx->use_cur_last_event_ts = 1;
		ctx->cbs.open_packet(ctx->data);
		ctx->use_cur_last_event_ts = 0;
	}

	/* Event fits the current packet? */
	if (er_size > (ctx->packet_size - ctx->at)) {
		/* No: close packet now */
		ctx->use_cur_last_event_ts = 1;
		ctx->cbs.close_packet(ctx->data);
		ctx->use_cur_last_event_ts = 0;

		/* Is the back end full? */
		if (ctx->cbs.is_backend_full(ctx->data)) {
			/* Yes: discard event record */
			goto no_space;
		}

		/* Back-end is _not_ full: open new packet */
		ctx->use_cur_last_event_ts = 1;
		ctx->cbs.open_packet(ctx->data);
		ctx->use_cur_last_event_ts = 0;
		assert(er_size <= (ctx->packet_size - ctx->at));
	}

	ret = 1;
	goto end;

no_space:
	ctx->events_discarded++;
	ret = 0;

end:
	return ret;
}

static
void _commit_er(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Is the packet full? */
	if (barectf_packet_is_full(ctx)) {
		/* Yes: close it now */
		ctx->cbs.close_packet(ctx->data);
	}
}

/* Initialize context */
void barectf_init(void *vctx,
	uint8_t * const buf, const uint32_t buf_size,
	const struct barectf_platform_callbacks cbs, void * const data)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	ctx->cbs = cbs;
	ctx->data = data;
	ctx->buf = buf;
	ctx->packet_size = _BYTES_TO_BITS(buf_size);
	ctx->at = 0;
	ctx->events_discarded = 0;
	ctx->packet_is_open = 0;
	ctx->in_tracing_section = 0;
	ctx->is_tracing_enabled = 1;
	ctx->use_cur_last_event_ts = 0;
}

/* Open packet for data stream type `default` */
void barectf_default_open_packet(
    struct barectf_default_ctx * const sctx, uint32_t cpu_id)
{
    struct barectf_ctx * const ctx = &sctx->parent;
    const uint64_t ts = ctx->use_cur_last_event_ts ?
        sctx->cur_last_event_ts :
        ctx->cbs.perf_counter_clock_get_value(ctx->data);
    const int saved_in_tracing_section = ctx->in_tracing_section;

    /*
     * This function is either called by a tracing function, or
     * directly by the platform.
     *
     * If it's called by a tracing function, then
     * `ctx->in_tracing_section` is 1, so it's safe to open
     * the packet here (alter the packet), even if tracing was
     * disabled in the meantime because we're already in a tracing
     * section (which finishes at the end of the tracing function
     * call).
     *
     * If it's called directly by the platform, then if tracing is
     * disabled, we don't want to alter the packet, and return
     * immediately.
     */
    if (!ctx->is_tracing_enabled && !saved_in_tracing_section) {
        ctx->in_tracing_section = 0;
        goto end;
    }

    /* We can alter the packet */
    ctx->in_tracing_section = 1;

    /* Do not open a packet that is already open */
    if (ctx->packet_is_open) {
        ctx->in_tracing_section = saved_in_tracing_section;
        goto end;
    }

    ctx->at = 0;

    /* Write packet header structure */
    {
        /* Align for packet header structure */
        _ALIGN(ctx->at, 8);

        /* Align for `magic` field */
        _ALIGN(ctx->at, 8);

        /* Write magic number field */
        {
            const uint32_t tmp_val = (uint32_t) 0xc1fc1fc1UL;

            memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
            ctx->at += 32;
        }

        /* Align for `stream_id` field */
        _ALIGN(ctx->at, 8);

        /* Write data stream type ID field */
        {
            const uint64_t tmp_val = (uint64_t) 0;

            memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
            ctx->at += 64;
        }
    }

    /* Write packet context structure */
    {
        /* Align for packet context structure */
        _ALIGN(ctx->at, 8);

        /* Align for `packet_size` field */
        _ALIGN(ctx->at, 8);

        /* Write packet total size field */
        {
            const uint64_t tmp_val = (uint64_t) ctx->packet_size;

            memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
            ctx->at += 64;
        }

        /* Align for `content_size` field */
        _ALIGN(ctx->at, 8);

        /* Do not write `content_size` field; save its offset */
        sctx->off_pc_content_size = ctx->at;
        ctx->at += 64;

        /* Align for `timestamp_begin` field */
        _ALIGN(ctx->at, 8);

        /* Write beginning timestamp field */
        {
            const uint64_t tmp_val = (uint64_t) ts;

            memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
            ctx->at += 64;
        }

        /* Align for `timestamp_end` field */
        _ALIGN(ctx->at, 8);

        /* Do not write `timestamp_end` field; save its offset */
        sctx->off_pc_timestamp_end = ctx->at;
        ctx->at += 64;

        /* Align for `events_discarded` field */
        _ALIGN(ctx->at, 8);

        /* Do not write `events_discarded` field; save its offset */
        sctx->off_pc_events_discarded = ctx->at;
        ctx->at += 64;

        /* Align for `cpu_id` field */
        _ALIGN(ctx->at, 8);

        /* Write cpu_id field */
        {
            const uint32_t tmp_val = cpu_id;

            memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
            ctx->at += 32;
        }
    }

    /* Save content beginning's offset */
    ctx->off_content = ctx->at;

    /* Mark current packet as open */
    ctx->packet_is_open = 1;

    /* Not tracing anymore */
    ctx->in_tracing_section = saved_in_tracing_section;

end:
    return;
}

/* Close packet for data stream type `default` */
void barectf_default_close_packet(struct barectf_default_ctx * const sctx)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	const uint64_t ts = ctx->use_cur_last_event_ts ?
		sctx->cur_last_event_ts :
		ctx->cbs.perf_counter_clock_get_value(ctx->data);
	const int saved_in_tracing_section = ctx->in_tracing_section;

	/*
	 * This function is either called by a tracing function, or
	 * directly by the platform.
	 *
	 * If it's called by a tracing function, then
	 * `ctx->in_tracing_section` is 1, so it's safe to close
	 * the packet here (alter the packet), even if tracing was
	 * disabled in the meantime, because we're already in a tracing
	 * section (which finishes at the end of the tracing function
	 * call).
	 *
	 * If it's called directly by the platform, then if tracing is
	 * disabled, we don't want to alter the packet, and return
	 * immediately.
	 */
	if (!ctx->is_tracing_enabled && !saved_in_tracing_section) {
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Do not close a packet that is not open */
	if (!ctx->packet_is_open) {
		ctx->in_tracing_section = saved_in_tracing_section;
		goto end;
	}

	/* Save content size */
	ctx->content_size = ctx->at;

	/* Go back to `timestamp_end` field offset */
	ctx->at = sctx->off_pc_timestamp_end;

	/* Write `timestamp_end` field */
	{
		const uint64_t tmp_val = (uint64_t) ts;

		memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
		ctx->at += 64;
	}

	/* Go back to `content_size` field offset */
	ctx->at = sctx->off_pc_content_size;

	/* Write `content_size` field */
	{
		const uint64_t tmp_val = (uint64_t) ctx->content_size;

		memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
		ctx->at += 64;
	}

	/* Go back to `events_discarded` field offset */
	ctx->at = sctx->off_pc_events_discarded;

	/* Write `events_discarded` field */
	{
		const uint64_t tmp_val = (uint64_t) ctx->events_discarded;

		memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
		ctx->at += 64;
	}

	/* Go back to end of packet */
	ctx->at = ctx->packet_size;

	/* Mark packet as closed */
	ctx->packet_is_open = 0;

	/* Not tracing anymore */
	ctx->in_tracing_section = saved_in_tracing_section;

end:
	return;
}

static void _serialize_er_header_default(void * const vctx,
	const uint32_t ert_id)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	struct barectf_default_ctx * const sctx = _FROM_VOID_PTR(struct barectf_default_ctx, vctx);
	const uint64_t ts = sctx->cur_last_event_ts;

	/* Write header structure */
	{
		/* Align for header structure */
		_ALIGN(ctx->at, 8);

		/* Align for `id` field */
		_ALIGN(ctx->at, 8);

		/* Write event record type ID field */
		{
			const uint64_t tmp_val = (uint64_t) ert_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `timestamp` field */
		_ALIGN(ctx->at, 8);

		/* Write timestamp field */
		{
			const uint64_t tmp_val = (uint64_t) ts;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_block_rq_complete(void * const vctx,
	const uint32_t p__dev,
	const uint64_t p__sector,
	const uint32_t p__nr_sector,
	const int32_t p__error,
	const uint32_t p__rwbs)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 0);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_dev` field */
		_ALIGN(ctx->at, 8);

		/* Write `_dev` field */
		{
			const uint32_t tmp_val = (uint32_t) p__dev;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_sector` field */
		_ALIGN(ctx->at, 8);

		/* Write `_sector` field */
		{
			const uint64_t tmp_val = (uint64_t) p__sector;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_nr_sector` field */
		_ALIGN(ctx->at, 8);

		/* Write `_nr_sector` field */
		{
			const uint32_t tmp_val = (uint32_t) p__nr_sector;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_error` field */
		_ALIGN(ctx->at, 8);

		/* Write `_error` field */
		{
			const uint32_t tmp_val = (uint32_t) p__error;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_rwbs` field */
		_ALIGN(ctx->at, 8);

		/* Write `_rwbs` field */
		{
			const uint32_t tmp_val = (uint32_t) p__rwbs;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_block_rq_insert(void * const vctx,
	const uint32_t p__dev,
	const uint64_t p__sector,
	const uint32_t p__nr_sector,
	const uint32_t p__bytes,
	const int32_t p__tid,
	const uint32_t p__rwbs,
	const int8_t * const p__comm)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 1);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_dev` field */
		_ALIGN(ctx->at, 8);

		/* Write `_dev` field */
		{
			const uint32_t tmp_val = (uint32_t) p__dev;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_sector` field */
		_ALIGN(ctx->at, 8);

		/* Write `_sector` field */
		{
			const uint64_t tmp_val = (uint64_t) p__sector;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_nr_sector` field */
		_ALIGN(ctx->at, 8);

		/* Write `_nr_sector` field */
		{
			const uint32_t tmp_val = (uint32_t) p__nr_sector;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_bytes` field */
		_ALIGN(ctx->at, 8);

		/* Write `_bytes` field */
		{
			const uint32_t tmp_val = (uint32_t) p__bytes;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_rwbs` field */
		_ALIGN(ctx->at, 8);

		/* Write `_rwbs` field */
		{
			const uint32_t tmp_val = (uint32_t) p__rwbs;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}
	}
}

static void _serialize_er_default_irq_handler_entry(void * const vctx,
	const int32_t p__irq,
	const char * const p__name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 2);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_irq` field */
		_ALIGN(ctx->at, 8);

		/* Write `_irq` field */
		{
			const uint32_t tmp_val = (uint32_t) p__irq;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_name` field */
		_ALIGN(ctx->at, 8);

		/* Write `_name` field */
		_write_c_str(ctx, p__name);
	}
}

static void _serialize_er_default_irq_handler_exit(void * const vctx,
	const int32_t p__irq,
	const int32_t p__ret)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 3);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_irq` field */
		_ALIGN(ctx->at, 8);

		/* Write `_irq` field */
		{
			const uint32_t tmp_val = (uint32_t) p__irq;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_ret` field */
		_ALIGN(ctx->at, 8);

		/* Write `_ret` field */
		{
			const uint32_t tmp_val = (uint32_t) p__ret;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_irq_softirq_entry(void * const vctx,
	const int32_t p__vec)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 4);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_vec` field */
		_ALIGN(ctx->at, 8);

		/* Write `_vec` field */
		{
			const uint32_t tmp_val = (uint32_t) p__vec;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_irq_softirq_exit(void * const vctx,
	const int32_t p__vec)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 5);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_vec` field */
		_ALIGN(ctx->at, 8);

		/* Write `_vec` field */
		{
			const uint32_t tmp_val = (uint32_t) p__vec;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_irq_softirq_raise(void * const vctx,
	const int32_t p__vec)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 6);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_vec` field */
		_ALIGN(ctx->at, 8);

		/* Write `_vec` field */
		{
			const uint32_t tmp_val = (uint32_t) p__vec;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_kmem_mm_page_alloc(void * const vctx,
	const uint64_t p__page,
	const uint64_t p__pfn,
	const uint32_t p__order,
	const uint32_t p__gfp_flags,
	const int32_t p__migratetype)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 7);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_page` field */
		_ALIGN(ctx->at, 8);

		/* Write `_page` field */
		{
			const uint64_t tmp_val = (uint64_t) p__page;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_pfn` field */
		_ALIGN(ctx->at, 8);

		/* Write `_pfn` field */
		{
			const uint64_t tmp_val = (uint64_t) p__pfn;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_order` field */
		_ALIGN(ctx->at, 8);

		/* Write `_order` field */
		{
			const uint32_t tmp_val = (uint32_t) p__order;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_gfp_flags` field */
		_ALIGN(ctx->at, 8);

		/* Write `_gfp_flags` field */
		{
			const uint32_t tmp_val = (uint32_t) p__gfp_flags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_migratetype` field */
		_ALIGN(ctx->at, 8);

		/* Write `_migratetype` field */
		{
			const uint32_t tmp_val = (uint32_t) p__migratetype;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_kmem_mm_page_free(void * const vctx,
	const uint64_t p__page,
	const uint64_t p__pfn,
	const uint32_t p__order)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 8);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_page` field */
		_ALIGN(ctx->at, 8);

		/* Write `_page` field */
		{
			const uint64_t tmp_val = (uint64_t) p__page;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_pfn` field */
		_ALIGN(ctx->at, 8);

		/* Write `_pfn` field */
		{
			const uint64_t tmp_val = (uint64_t) p__pfn;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_order` field */
		_ALIGN(ctx->at, 8);

		/* Write `_order` field */
		{
			const uint32_t tmp_val = (uint32_t) p__order;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_lttng_statedump_process_state(void * const vctx,
	const int32_t p__tid,
	const int32_t p__pid,
	const int8_t * const p__name,
	const uint32_t p__parent_ns_inum,
	const int32_t p__type,
	const int32_t p__mode,
	const int32_t p__submode,
	const int32_t p__status,
	const uint32_t p__cpu,
	const uint64_t p__file_table_address)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 9);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_pid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_pid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__pid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_name` field */
		_ALIGN(ctx->at, 8);

		/* Write `_name` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__name[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_parent_ns_inum` field */
		_ALIGN(ctx->at, 8);

		/* Write `_parent_ns_inum` field */
		{
			const uint32_t tmp_val = (uint32_t) p__parent_ns_inum;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_type` field */
		_ALIGN(ctx->at, 8);

		/* Write `_type` field */
		{
			const uint32_t tmp_val = (uint32_t) p__type;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_mode` field */
		_ALIGN(ctx->at, 8);

		/* Write `_mode` field */
		{
			const uint32_t tmp_val = (uint32_t) p__mode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_submode` field */
		_ALIGN(ctx->at, 8);

		/* Write `_submode` field */
		{
			const uint32_t tmp_val = (uint32_t) p__submode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_status` field */
		_ALIGN(ctx->at, 8);

		/* Write `_status` field */
		{
			const uint32_t tmp_val = (uint32_t) p__status;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_cpu` field */
		_ALIGN(ctx->at, 8);

		/* Write `_cpu` field */
		{
			const uint32_t tmp_val = (uint32_t) p__cpu;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_file_table_address` field */
		_ALIGN(ctx->at, 8);

		/* Write `_file_table_address` field */
		{
			const uint64_t tmp_val = (uint64_t) p__file_table_address;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_sched_pi_setprio(void * const vctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__oldprio,
	const int32_t p__newprio)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 10);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_oldprio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_oldprio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__oldprio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_newprio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_newprio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__newprio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_sched_process_exit(void * const vctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 11);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_prio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__prio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_sched_process_fork(void * const vctx,
	const int8_t * const p__parent_comm,
	const int32_t p__parent_tid,
	const int32_t p__parent_pid,
	const uint32_t p__parent_ns_inum,
	const int8_t * const p__child_comm,
	const int32_t p__child_tid,
	const uint8_t p___vtids_length,
	const uint32_t p____vtids_len,
	const int32_t * const p__vtids,
	const int32_t p__child_pid,
	const uint32_t p__child_ns_inum)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 12);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `_parent_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_parent_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__parent_comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_parent_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_parent_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__parent_tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_parent_pid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_parent_pid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__parent_pid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_parent_ns_inum` field */
		_ALIGN(ctx->at, 8);

		/* Write `_parent_ns_inum` field */
		{
			const uint32_t tmp_val = (uint32_t) p__parent_ns_inum;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_child_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_child_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__child_comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_child_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_child_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__child_tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `__vtids_length` field */
		_ALIGN(ctx->at, 8);

		/* Write `__vtids_length` field */
		{
			const uint8_t tmp_val = (uint8_t) p___vtids_length;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `___vtids_len` field */
		_ALIGN(ctx->at, 8);

		/* Write `___vtids_len` field */
		{
			const uint32_t tmp_val = (uint32_t) p____vtids_len;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_vtids` field */
		_ALIGN(ctx->at, 32);

		/* Write `_vtids` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) p____vtids_len; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 32);

				/* Write `[i]` field */
				{
					const uint32_t tmp_val = (uint32_t) p__vtids[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 32;
				}
			}
		}

		/* Align for `_child_pid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_child_pid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__child_pid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_child_ns_inum` field */
		_ALIGN(ctx->at, 8);

		/* Write `_child_ns_inum` field */
		{
			const uint32_t tmp_val = (uint32_t) p__child_ns_inum;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_sched_process_free(void * const vctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 13);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_prio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__prio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_sched_process_wait(void * const vctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 14);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_prio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__prio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_sched_switch(void * const vctx,
	const int8_t * const p__prev_comm,
	const int32_t p__prev_tid,
	const int32_t p__prev_prio,
	const int64_t p__prev_state,
	const int8_t * const p__next_comm,
	const int32_t p__next_tid,
	const int32_t p__next_prio)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 15);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_prev_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prev_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__prev_comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_prev_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prev_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__prev_tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_prev_prio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prev_prio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__prev_prio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_prev_state` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prev_state` field */
		{
			const uint64_t tmp_val = (uint64_t) p__prev_state;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_next_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_next_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__next_comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_next_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_next_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__next_tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_next_prio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_next_prio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__next_prio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_sched_wait_task(void * const vctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 16);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_prio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__prio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_sched_wakeup(void * const vctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio,
	const int32_t p__target_cpu)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 17);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_prio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__prio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_target_cpu` field */
		_ALIGN(ctx->at, 8);

		/* Write `_target_cpu` field */
		{
			const uint32_t tmp_val = (uint32_t) p__target_cpu;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_sched_wakeup_new(void * const vctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio,
	const int32_t p__target_cpu)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 18);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_comm` field */
		_ALIGN(ctx->at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 8);

				/* Write `[i]` field */
				{
					const uint8_t tmp_val = (uint8_t) p__comm[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 8;
				}
			}
		}

		/* Align for `_tid` field */
		_ALIGN(ctx->at, 8);

		/* Write `_tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p__tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_prio` field */
		_ALIGN(ctx->at, 8);

		/* Write `_prio` field */
		{
			const uint32_t tmp_val = (uint32_t) p__prio;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_target_cpu` field */
		_ALIGN(ctx->at, 8);

		/* Write `_target_cpu` field */
		{
			const uint32_t tmp_val = (uint32_t) p__target_cpu;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_syscall_entry_futex(void * const vctx,
	const uint64_t p__uaddr,
	const int32_t p__op,
	const uint32_t p__val,
	const uint64_t p__utime,
	const uint64_t p__uaddr2,
	const uint32_t p__val3)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 19);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_uaddr` field */
		_ALIGN(ctx->at, 8);

		/* Write `_uaddr` field */
		{
			const uint64_t tmp_val = (uint64_t) p__uaddr;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_op` field */
		_ALIGN(ctx->at, 8);

		/* Write `_op` field */
		{
			const uint32_t tmp_val = (uint32_t) p__op;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_val` field */
		_ALIGN(ctx->at, 8);

		/* Write `_val` field */
		{
			const uint32_t tmp_val = (uint32_t) p__val;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `_utime` field */
		_ALIGN(ctx->at, 8);

		/* Write `_utime` field */
		{
			const uint64_t tmp_val = (uint64_t) p__utime;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_uaddr2` field */
		_ALIGN(ctx->at, 8);

		/* Write `_uaddr2` field */
		{
			const uint64_t tmp_val = (uint64_t) p__uaddr2;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_val3` field */
		_ALIGN(ctx->at, 8);

		/* Write `_val3` field */
		{
			const uint32_t tmp_val = (uint32_t) p__val3;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_syscall_exit_futex(void * const vctx,
	const int64_t p__ret,
	const uint64_t p__uaddr,
	const uint64_t p__uaddr2)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 20);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_ret` field */
		_ALIGN(ctx->at, 8);

		/* Write `_ret` field */
		{
			const uint64_t tmp_val = (uint64_t) p__ret;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_uaddr` field */
		_ALIGN(ctx->at, 8);

		/* Write `_uaddr` field */
		{
			const uint64_t tmp_val = (uint64_t) p__uaddr;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_uaddr2` field */
		_ALIGN(ctx->at, 8);

		/* Write `_uaddr2` field */
		{
			const uint64_t tmp_val = (uint64_t) p__uaddr2;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_timer_hrtimer_cancel(void * const vctx,
	const uint64_t p__hrtimer)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 21);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_hrtimer` field */
		_ALIGN(ctx->at, 8);

		/* Write `_hrtimer` field */
		{
			const uint64_t tmp_val = (uint64_t) p__hrtimer;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_timer_hrtimer_expire_entry(void * const vctx,
	const uint64_t p__hrtimer,
	const int64_t p__now,
	const uint64_t p__function)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 22);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_hrtimer` field */
		_ALIGN(ctx->at, 8);

		/* Write `_hrtimer` field */
		{
			const uint64_t tmp_val = (uint64_t) p__hrtimer;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_now` field */
		_ALIGN(ctx->at, 8);

		/* Write `_now` field */
		{
			const uint64_t tmp_val = (uint64_t) p__now;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_function` field */
		_ALIGN(ctx->at, 8);

		/* Write `_function` field */
		{
			const uint64_t tmp_val = (uint64_t) p__function;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_timer_hrtimer_expire_exit(void * const vctx,
	const uint64_t p__hrtimer)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 23);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_hrtimer` field */
		_ALIGN(ctx->at, 8);

		/* Write `_hrtimer` field */
		{
			const uint64_t tmp_val = (uint64_t) p__hrtimer;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_timer_hrtimer_start(void * const vctx,
	const uint64_t p__hrtimer,
	const uint64_t p__function,
	const int64_t p__expires,
	const int64_t p__softexpires,
	const uint32_t p__mode)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 24);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `_hrtimer` field */
		_ALIGN(ctx->at, 8);

		/* Write `_hrtimer` field */
		{
			const uint64_t tmp_val = (uint64_t) p__hrtimer;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_function` field */
		_ALIGN(ctx->at, 8);

		/* Write `_function` field */
		{
			const uint64_t tmp_val = (uint64_t) p__function;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_expires` field */
		_ALIGN(ctx->at, 8);

		/* Write `_expires` field */
		{
			const uint64_t tmp_val = (uint64_t) p__expires;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_softexpires` field */
		_ALIGN(ctx->at, 8);

		/* Write `_softexpires` field */
		{
			const uint64_t tmp_val = (uint64_t) p__softexpires;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `_mode` field */
		_ALIGN(ctx->at, 8);

		/* Write `_mode` field */
		{
			const uint32_t tmp_val = (uint32_t) p__mode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static uint32_t _er_size_default_block_rq_complete(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_dev` field */
		_ALIGN(at, 8);

		/* Add `_dev` bit array field's size */
		at += 32;

		/* Align for `_sector` field */
		_ALIGN(at, 8);

		/* Add `_sector` bit array field's size */
		at += 64;

		/* Align for `_nr_sector` field */
		_ALIGN(at, 8);

		/* Add `_nr_sector` bit array field's size */
		at += 32;

		/* Align for `_error` field */
		_ALIGN(at, 8);

		/* Add `_error` bit array field's size */
		at += 32;

		/* Align for `_rwbs` field */
		_ALIGN(at, 8);

		/* Add `_rwbs` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_block_rq_insert(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_dev` field */
		_ALIGN(at, 8);

		/* Add `_dev` bit array field's size */
		at += 32;

		/* Align for `_sector` field */
		_ALIGN(at, 8);

		/* Add `_sector` bit array field's size */
		at += 64;

		/* Align for `_nr_sector` field */
		_ALIGN(at, 8);

		/* Add `_nr_sector` bit array field's size */
		at += 32;

		/* Align for `_bytes` field */
		_ALIGN(at, 8);

		/* Add `_bytes` bit array field's size */
		at += 32;

		/* Align for `_tid` field */
		_ALIGN(at, 8);

		/* Add `_tid` bit array field's size */
		at += 32;

		/* Align for `_rwbs` field */
		_ALIGN(at, 8);

		/* Add `_rwbs` bit array field's size */
		at += 32;

		/* Align for `_comm` field */
		_ALIGN(at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_irq_handler_entry(void * const vctx,
	const char * const p__name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_irq` field */
		_ALIGN(at, 8);

		/* Add `_irq` bit array field's size */
		at += 32;

		/* Align for `_name` field */
		_ALIGN(at, 8);

		/* Add `_name` string field's size */
		at += _BYTES_TO_BITS(strlen(p__name) + 1);
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_irq_handler_exit(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_irq` field */
		_ALIGN(at, 8);

		/* Add `_irq` bit array field's size */
		at += 32;

		/* Align for `_ret` field */
		_ALIGN(at, 8);

		/* Add `_ret` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_irq_softirq_entry(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_vec` field */
		_ALIGN(at, 8);

		/* Add `_vec` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_irq_softirq_exit(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_vec` field */
		_ALIGN(at, 8);

		/* Add `_vec` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_irq_softirq_raise(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_vec` field */
		_ALIGN(at, 8);

		/* Add `_vec` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_kmem_mm_page_alloc(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_page` field */
		_ALIGN(at, 8);

		/* Add `_page` bit array field's size */
		at += 64;

		/* Align for `_pfn` field */
		_ALIGN(at, 8);

		/* Add `_pfn` bit array field's size */
		at += 64;

		/* Align for `_order` field */
		_ALIGN(at, 8);

		/* Add `_order` bit array field's size */
		at += 32;

		/* Align for `_gfp_flags` field */
		_ALIGN(at, 8);

		/* Add `_gfp_flags` bit array field's size */
		at += 32;

		/* Align for `_migratetype` field */
		_ALIGN(at, 8);

		/* Add `_migratetype` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_kmem_mm_page_free(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_page` field */
		_ALIGN(at, 8);

		/* Add `_page` bit array field's size */
		at += 64;

		/* Align for `_pfn` field */
		_ALIGN(at, 8);

		/* Add `_pfn` bit array field's size */
		at += 64;

		/* Align for `_order` field */
		_ALIGN(at, 8);

		/* Add `_order` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_lttng_statedump_process_state(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_tid` field */
		_ALIGN(at, 8);

		/* Add `_tid` bit array field's size */
		at += 32;

		/* Align for `_pid` field */
		_ALIGN(at, 8);

		/* Add `_pid` bit array field's size */
		at += 32;

		/* Align for `_name` field */
		_ALIGN(at, 8);

		/* Write `_name` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_parent_ns_inum` field */
		_ALIGN(at, 8);

		/* Add `_parent_ns_inum` bit array field's size */
		at += 32;

		/* Align for `_type` field */
		_ALIGN(at, 8);

		/* Add `_type` bit array field's size */
		at += 32;

		/* Align for `_mode` field */
		_ALIGN(at, 8);

		/* Add `_mode` bit array field's size */
		at += 32;

		/* Align for `_submode` field */
		_ALIGN(at, 8);

		/* Add `_submode` bit array field's size */
		at += 32;

		/* Align for `_status` field */
		_ALIGN(at, 8);

		/* Add `_status` bit array field's size */
		at += 32;

		/* Align for `_cpu` field */
		_ALIGN(at, 8);

		/* Add `_cpu` bit array field's size */
		at += 32;

		/* Align for `_file_table_address` field */
		_ALIGN(at, 8);

		/* Add `_file_table_address` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_sched_pi_setprio(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_comm` field */
		_ALIGN(at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_tid` field */
		_ALIGN(at, 8);

		/* Add `_tid` bit array field's size */
		at += 32;

		/* Align for `_oldprio` field */
		_ALIGN(at, 8);

		/* Add `_oldprio` bit array field's size */
		at += 32;

		/* Align for `_newprio` field */
		_ALIGN(at, 8);

		/* Add `_newprio` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_sched_process_exit(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_comm` field */
		_ALIGN(at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_tid` field */
		_ALIGN(at, 8);

		/* Add `_tid` bit array field's size */
		at += 32;

		/* Align for `_prio` field */
		_ALIGN(at, 8);

		/* Add `_prio` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_sched_process_fork(void * const vctx,
	const uint32_t p____vtids_len,
	const int32_t * const p__vtids)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `_parent_comm` field */
		_ALIGN(at, 8);

		/* Write `_parent_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_parent_tid` field */
		_ALIGN(at, 8);

		/* Add `_parent_tid` bit array field's size */
		at += 32;

		/* Align for `_parent_pid` field */
		_ALIGN(at, 8);

		/* Add `_parent_pid` bit array field's size */
		at += 32;

		/* Align for `_parent_ns_inum` field */
		_ALIGN(at, 8);

		/* Add `_parent_ns_inum` bit array field's size */
		at += 32;

		/* Align for `_child_comm` field */
		_ALIGN(at, 8);

		/* Write `_child_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_child_tid` field */
		_ALIGN(at, 8);

		/* Add `_child_tid` bit array field's size */
		at += 32;

		/* Align for `__vtids_length` field */
		_ALIGN(at, 8);

		/* Add `__vtids_length` bit array field's size */
		at += 8;

		/* Align for `___vtids_len` field */
		_ALIGN(at, 8);

		/* Add `___vtids_len` bit array field's size */
		at += 32;

		/* Align for `_vtids` field */
		_ALIGN(at, 32);

		/* Write `_vtids` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) p____vtids_len; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 32);

				/* Add `[i]` bit array field's size */
				at += 32;
			}
		}

		/* Align for `_child_pid` field */
		_ALIGN(at, 8);

		/* Add `_child_pid` bit array field's size */
		at += 32;

		/* Align for `_child_ns_inum` field */
		_ALIGN(at, 8);

		/* Add `_child_ns_inum` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_sched_process_free(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_comm` field */
		_ALIGN(at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_tid` field */
		_ALIGN(at, 8);

		/* Add `_tid` bit array field's size */
		at += 32;

		/* Align for `_prio` field */
		_ALIGN(at, 8);

		/* Add `_prio` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_sched_process_wait(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_comm` field */
		_ALIGN(at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_tid` field */
		_ALIGN(at, 8);

		/* Add `_tid` bit array field's size */
		at += 32;

		/* Align for `_prio` field */
		_ALIGN(at, 8);

		/* Add `_prio` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_sched_switch(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_prev_comm` field */
		_ALIGN(at, 8);

		/* Write `_prev_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_prev_tid` field */
		_ALIGN(at, 8);

		/* Add `_prev_tid` bit array field's size */
		at += 32;

		/* Align for `_prev_prio` field */
		_ALIGN(at, 8);

		/* Add `_prev_prio` bit array field's size */
		at += 32;

		/* Align for `_prev_state` field */
		_ALIGN(at, 8);

		/* Add `_prev_state` bit array field's size */
		at += 64;

		/* Align for `_next_comm` field */
		_ALIGN(at, 8);

		/* Write `_next_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_next_tid` field */
		_ALIGN(at, 8);

		/* Add `_next_tid` bit array field's size */
		at += 32;

		/* Align for `_next_prio` field */
		_ALIGN(at, 8);

		/* Add `_next_prio` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_sched_wait_task(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_comm` field */
		_ALIGN(at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_tid` field */
		_ALIGN(at, 8);

		/* Add `_tid` bit array field's size */
		at += 32;

		/* Align for `_prio` field */
		_ALIGN(at, 8);

		/* Add `_prio` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_sched_wakeup(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_comm` field */
		_ALIGN(at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_tid` field */
		_ALIGN(at, 8);

		/* Add `_tid` bit array field's size */
		at += 32;

		/* Align for `_prio` field */
		_ALIGN(at, 8);

		/* Add `_prio` bit array field's size */
		at += 32;

		/* Align for `_target_cpu` field */
		_ALIGN(at, 8);

		/* Add `_target_cpu` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_sched_wakeup_new(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_comm` field */
		_ALIGN(at, 8);

		/* Write `_comm` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) 16U; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 8);

				/* Add `[i]` bit array field's size */
				at += 8;
			}
		}

		/* Align for `_tid` field */
		_ALIGN(at, 8);

		/* Add `_tid` bit array field's size */
		at += 32;

		/* Align for `_prio` field */
		_ALIGN(at, 8);

		/* Add `_prio` bit array field's size */
		at += 32;

		/* Align for `_target_cpu` field */
		_ALIGN(at, 8);

		/* Add `_target_cpu` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_syscall_entry_futex(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_uaddr` field */
		_ALIGN(at, 8);

		/* Add `_uaddr` bit array field's size */
		at += 64;

		/* Align for `_op` field */
		_ALIGN(at, 8);

		/* Add `_op` bit array field's size */
		at += 32;

		/* Align for `_val` field */
		_ALIGN(at, 8);

		/* Add `_val` bit array field's size */
		at += 32;

		/* Align for `_utime` field */
		_ALIGN(at, 8);

		/* Add `_utime` bit array field's size */
		at += 64;

		/* Align for `_uaddr2` field */
		_ALIGN(at, 8);

		/* Add `_uaddr2` bit array field's size */
		at += 64;

		/* Align for `_val3` field */
		_ALIGN(at, 8);

		/* Add `_val3` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_syscall_exit_futex(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_ret` field */
		_ALIGN(at, 8);

		/* Add `_ret` bit array field's size */
		at += 64;

		/* Align for `_uaddr` field */
		_ALIGN(at, 8);

		/* Add `_uaddr` bit array field's size */
		at += 64;

		/* Align for `_uaddr2` field */
		_ALIGN(at, 8);

		/* Add `_uaddr2` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_timer_hrtimer_cancel(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_hrtimer` field */
		_ALIGN(at, 8);

		/* Add `_hrtimer` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_timer_hrtimer_expire_entry(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_hrtimer` field */
		_ALIGN(at, 8);

		/* Add `_hrtimer` bit array field's size */
		at += 64;

		/* Align for `_now` field */
		_ALIGN(at, 8);

		/* Add `_now` bit array field's size */
		at += 64;

		/* Align for `_function` field */
		_ALIGN(at, 8);

		/* Add `_function` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_timer_hrtimer_expire_exit(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_hrtimer` field */
		_ALIGN(at, 8);

		/* Add `_hrtimer` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_timer_hrtimer_start(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `_hrtimer` field */
		_ALIGN(at, 8);

		/* Add `_hrtimer` bit array field's size */
		at += 64;

		/* Align for `_function` field */
		_ALIGN(at, 8);

		/* Add `_function` bit array field's size */
		at += 64;

		/* Align for `_expires` field */
		_ALIGN(at, 8);

		/* Add `_expires` bit array field's size */
		at += 64;

		/* Align for `_softexpires` field */
		_ALIGN(at, 8);

		/* Add `_softexpires` bit array field's size */
		at += 64;

		/* Align for `_mode` field */
		_ALIGN(at, 8);

		/* Add `_mode` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

/* Trace (data stream type `default`, event record type `block_rq_complete`) */
void barectf_default_trace_block_rq_complete(struct barectf_default_ctx * const sctx,
	const uint32_t p__dev,
	const uint64_t p__sector,
	const uint32_t p__nr_sector,
	const int32_t p__error,
	const uint32_t p__rwbs)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_block_rq_complete(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_block_rq_complete(_TO_VOID_PTR(ctx), p__dev, p__sector, p__nr_sector, p__error, p__rwbs);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `block_rq_insert`) */
void barectf_default_trace_block_rq_insert(struct barectf_default_ctx * const sctx,
	const uint32_t p__dev,
	const uint64_t p__sector,
	const uint32_t p__nr_sector,
	const uint32_t p__bytes,
	const int32_t p__tid,
	const uint32_t p__rwbs,
	const int8_t * const p__comm)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_block_rq_insert(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_block_rq_insert(_TO_VOID_PTR(ctx), p__dev, p__sector, p__nr_sector, p__bytes, p__tid, p__rwbs, p__comm);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `irq_handler_entry`) */
void barectf_default_trace_irq_handler_entry(struct barectf_default_ctx * const sctx,
	const int32_t p__irq,
	const char * const p__name)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_irq_handler_entry(_TO_VOID_PTR(ctx), p__name);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_irq_handler_entry(_TO_VOID_PTR(ctx), p__irq, p__name);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `irq_handler_exit`) */
void barectf_default_trace_irq_handler_exit(struct barectf_default_ctx * const sctx,
	const int32_t p__irq,
	const int32_t p__ret)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_irq_handler_exit(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_irq_handler_exit(_TO_VOID_PTR(ctx), p__irq, p__ret);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `irq_softirq_entry`) */
void barectf_default_trace_irq_softirq_entry(struct barectf_default_ctx * const sctx,
	const int32_t p__vec)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_irq_softirq_entry(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_irq_softirq_entry(_TO_VOID_PTR(ctx), p__vec);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `irq_softirq_exit`) */
void barectf_default_trace_irq_softirq_exit(struct barectf_default_ctx * const sctx,
	const int32_t p__vec)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_irq_softirq_exit(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_irq_softirq_exit(_TO_VOID_PTR(ctx), p__vec);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `irq_softirq_raise`) */
void barectf_default_trace_irq_softirq_raise(struct barectf_default_ctx * const sctx,
	const int32_t p__vec)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_irq_softirq_raise(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_irq_softirq_raise(_TO_VOID_PTR(ctx), p__vec);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `kmem_mm_page_alloc`) */
void barectf_default_trace_kmem_mm_page_alloc(struct barectf_default_ctx * const sctx,
	const uint64_t p__page,
	const uint64_t p__pfn,
	const uint32_t p__order,
	const uint32_t p__gfp_flags,
	const int32_t p__migratetype)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_kmem_mm_page_alloc(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_kmem_mm_page_alloc(_TO_VOID_PTR(ctx), p__page, p__pfn, p__order, p__gfp_flags, p__migratetype);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `kmem_mm_page_free`) */
void barectf_default_trace_kmem_mm_page_free(struct barectf_default_ctx * const sctx,
	const uint64_t p__page,
	const uint64_t p__pfn,
	const uint32_t p__order)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_kmem_mm_page_free(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_kmem_mm_page_free(_TO_VOID_PTR(ctx), p__page, p__pfn, p__order);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `lttng_statedump_process_state`) */
void barectf_default_trace_lttng_statedump_process_state(struct barectf_default_ctx * const sctx,
	const int32_t p__tid,
	const int32_t p__pid,
	const int8_t * const p__name,
	const uint32_t p__parent_ns_inum,
	const int32_t p__type,
	const int32_t p__mode,
	const int32_t p__submode,
	const int32_t p__status,
	const uint32_t p__cpu,
	const uint64_t p__file_table_address)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_lttng_statedump_process_state(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_lttng_statedump_process_state(_TO_VOID_PTR(ctx), p__tid, p__pid, p__name, p__parent_ns_inum, p__type, p__mode, p__submode, p__status, p__cpu, p__file_table_address);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `sched_pi_setprio`) */
void barectf_default_trace_sched_pi_setprio(struct barectf_default_ctx * const sctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__oldprio,
	const int32_t p__newprio)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_sched_pi_setprio(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_sched_pi_setprio(_TO_VOID_PTR(ctx), p__comm, p__tid, p__oldprio, p__newprio);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `sched_process_exit`) */
void barectf_default_trace_sched_process_exit(struct barectf_default_ctx * const sctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_sched_process_exit(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_sched_process_exit(_TO_VOID_PTR(ctx), p__comm, p__tid, p__prio);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `sched_process_fork`) */
void barectf_default_trace_sched_process_fork(struct barectf_default_ctx * const sctx,
	const int8_t * const p__parent_comm,
	const int32_t p__parent_tid,
	const int32_t p__parent_pid,
	const uint32_t p__parent_ns_inum,
	const int8_t * const p__child_comm,
	const int32_t p__child_tid,
	const uint8_t p___vtids_length,
	const uint32_t p____vtids_len,
	const int32_t * const p__vtids,
	const int32_t p__child_pid,
	const uint32_t p__child_ns_inum)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_sched_process_fork(_TO_VOID_PTR(ctx), p____vtids_len, p__vtids);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_sched_process_fork(_TO_VOID_PTR(ctx), p__parent_comm, p__parent_tid, p__parent_pid, p__parent_ns_inum, p__child_comm, p__child_tid, p___vtids_length, p____vtids_len, p__vtids, p__child_pid, p__child_ns_inum);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `sched_process_free`) */
void barectf_default_trace_sched_process_free(struct barectf_default_ctx * const sctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_sched_process_free(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_sched_process_free(_TO_VOID_PTR(ctx), p__comm, p__tid, p__prio);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `sched_process_wait`) */
void barectf_default_trace_sched_process_wait(struct barectf_default_ctx * const sctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_sched_process_wait(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_sched_process_wait(_TO_VOID_PTR(ctx), p__comm, p__tid, p__prio);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `sched_switch`) */
void barectf_default_trace_sched_switch(struct barectf_default_ctx * const sctx,
	const int8_t * const p__prev_comm,
	const int32_t p__prev_tid,
	const int32_t p__prev_prio,
	const int64_t p__prev_state,
	const int8_t * const p__next_comm,
	const int32_t p__next_tid,
	const int32_t p__next_prio)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_sched_switch(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_sched_switch(_TO_VOID_PTR(ctx), p__prev_comm, p__prev_tid, p__prev_prio, p__prev_state, p__next_comm, p__next_tid, p__next_prio);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `sched_wait_task`) */
void barectf_default_trace_sched_wait_task(struct barectf_default_ctx * const sctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_sched_wait_task(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_sched_wait_task(_TO_VOID_PTR(ctx), p__comm, p__tid, p__prio);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `sched_wakeup`) */
void barectf_default_trace_sched_wakeup(struct barectf_default_ctx * const sctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio,
	const int32_t p__target_cpu)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_sched_wakeup(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_sched_wakeup(_TO_VOID_PTR(ctx), p__comm, p__tid, p__prio, p__target_cpu);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `sched_wakeup_new`) */
void barectf_default_trace_sched_wakeup_new(struct barectf_default_ctx * const sctx,
	const int8_t * const p__comm,
	const int32_t p__tid,
	const int32_t p__prio,
	const int32_t p__target_cpu)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_sched_wakeup_new(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_sched_wakeup_new(_TO_VOID_PTR(ctx), p__comm, p__tid, p__prio, p__target_cpu);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `syscall_entry_futex`) */
void barectf_default_trace_syscall_entry_futex(struct barectf_default_ctx * const sctx,
	const uint64_t p__uaddr,
	const int32_t p__op,
	const uint32_t p__val,
	const uint64_t p__utime,
	const uint64_t p__uaddr2,
	const uint32_t p__val3)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_syscall_entry_futex(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_syscall_entry_futex(_TO_VOID_PTR(ctx), p__uaddr, p__op, p__val, p__utime, p__uaddr2, p__val3);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `syscall_exit_futex`) */
void barectf_default_trace_syscall_exit_futex(struct barectf_default_ctx * const sctx,
	const int64_t p__ret,
	const uint64_t p__uaddr,
	const uint64_t p__uaddr2)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_syscall_exit_futex(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_syscall_exit_futex(_TO_VOID_PTR(ctx), p__ret, p__uaddr, p__uaddr2);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `timer_hrtimer_cancel`) */
void barectf_default_trace_timer_hrtimer_cancel(struct barectf_default_ctx * const sctx,
	const uint64_t p__hrtimer)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_timer_hrtimer_cancel(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_timer_hrtimer_cancel(_TO_VOID_PTR(ctx), p__hrtimer);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `timer_hrtimer_expire_entry`) */
void barectf_default_trace_timer_hrtimer_expire_entry(struct barectf_default_ctx * const sctx,
	const uint64_t p__hrtimer,
	const int64_t p__now,
	const uint64_t p__function)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_timer_hrtimer_expire_entry(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_timer_hrtimer_expire_entry(_TO_VOID_PTR(ctx), p__hrtimer, p__now, p__function);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `timer_hrtimer_expire_exit`) */
void barectf_default_trace_timer_hrtimer_expire_exit(struct barectf_default_ctx * const sctx,
	const uint64_t p__hrtimer)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_timer_hrtimer_expire_exit(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_timer_hrtimer_expire_exit(_TO_VOID_PTR(ctx), p__hrtimer);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `timer_hrtimer_start`) */
void barectf_default_trace_timer_hrtimer_start(struct barectf_default_ctx * const sctx,
	const uint64_t p__hrtimer,
	const uint64_t p__function,
	const int64_t p__expires,
	const int64_t p__softexpires,
	const uint32_t p__mode)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.perf_counter_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_timer_hrtimer_start(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_timer_hrtimer_start(_TO_VOID_PTR(ctx), p__hrtimer, p__function, p__expires, p__softexpires, p__mode);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}
